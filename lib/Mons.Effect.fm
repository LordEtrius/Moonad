// sleep: Can't attack on the next turn
// burn: Loses 1/16 mhp for X turns
// protect: Takes 50% less damage on the next turn
// minimize: Takes 25% less damage for each of the next turns
// invulnerable: can't be attacked by effects of physical damage
// hit: a damage to be applied in the next turn
T Mons.Effect
| Mons.Effect.new(
  sleep: Bool,
  burn: U32, // turns that will last
  protect: Pair(U32, Bool), // fst: if 1u, will be applied on the same turn
  minimize: Pair(U32, Bool),
  invulnerable: Pair(Bool, Bool), // fst: if is invulnerable, snd: if used it last turn
  hit: U32
);

Mons.Effect.clear: Mons.Effect
  let clean = {0u, Bool.false}
  let clean_bool = {Bool.false, Bool.false}
  Mons.Effect.new(Bool.false, 0u, clean, clean, clean_bool, 0u)

Mons.Effect.upd_initial_eff(eff: Mons.Effect): Mons.Effect
  open eff:
  Mons.Effect.new(
    eff.sleep, 
    U32.sub(eff.burn, 1u), 
    eff.protect, 
    eff.minimize, 
    eff.invulnerable, 
    0u) // hit only last for the next turn

Mons.Effect.upd_end_turn_eff(eff: Mons.Effect): Mons.Effect
  open eff:
  let protect_turn = Pair.fst<,>(eff.protect)
  let minimize_turn = Pair.fst<,>(eff.minimize)
  let invulnerable = Pair.fst<,>(eff.invulnerable)
  let update_turn_counter = ((val) {U32.sub(val, 1u), U32.eql(val, 2u)}) :: U32 -> Pair(U32, Bool)
  Mons.Effect.new(
    Bool.false,
    eff.burn, 
    update_turn_counter(protect_turn),
    update_turn_counter(minimize_turn), 
    if invulnerable then {Bool.false, Bool.true} else {Bool.false, Bool.false}, 
    eff.hit)

Mons.Effect.has_sleep(eff: Mons.Effect): Bool
  open eff: 
  eff.sleep

Mons.Effect.has_burn(eff: Mons.Effect): Bool
  open eff: 
  U32.gtn(eff.burn, 0u)

// His only last 1 turn, so if it has a values, is the value of the dmg
Mons.Effect.has_hit(eff: Mons.Effect): Bool
  open eff:
  U32.gtn(eff.hit, 0u)

Mons.Effect.has_minimize(eff: Mons.Effect): Bool
  open eff: 
  get turn used = eff.minimize
  U32.gtn(turn, 0u)

// 0u: don't have
// 1u: it has protect for the current turn
// 2u: available next turn
Mons.Effect.has_protect(eff: Mons.Effect): Bool
  open eff: 
  let turn = Pair.fst<,>(eff.protect)
  U32.eql(turn, 1u)

Mons.Effect.has_invulnerable(eff: Mons.Effect): Bool
  open eff: 
  get stt used = eff.invulnerable
  stt

Mons.Effect.set_invulnerable(obj: Mons.Object): Mons.Object
  open obj:
  open obj.eff as eff:
  get stt used = eff.invulnerable
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    {Bool.true, Bool.true}, eff.hit)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_burn(obj: Mons.Object, turns: U32): Mons.Object
  open obj:
  open obj.eff as eff:
  let new_eff = Mons.Effect.new(eff.sleep, turns, eff.protect, eff.minimize, 
    eff.invulnerable, eff.hit)
  Mons.Object.set_eff(new_eff, obj)

// Hit to be executed next turn
Mons.Effect.set_hit(obj: Mons.Object, val: U32): Mons.Object
  open obj:
  open obj.eff as eff:
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, eff.protect, eff.minimize, 
    eff.invulnerable, val)
  Mons.Object.set_eff(new_eff, obj)

Mons.Effect.set_protect(obj: Mons.Object, turn: U32): Mons.Object
  open obj:
  open obj.eff as eff:
  let new_eff = Mons.Effect.new(eff.sleep, eff.burn, {turn, Bool.true}, eff.minimize, 
    eff.invulnerable, eff.hit)
  Mons.Object.set_eff(new_eff, obj)