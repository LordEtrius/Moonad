// TODO add more skills
T Mons.Skill
| Mons.Skill.hit_4;
| Mons.Skill.hit_2;
| Mons.Skill.heal;
| Mons.Skill.none;
| Mons.Skill.dig;
| Mons.Skill.sand_tomb;
| Mons.Skill.protect;
| Mons.Skill.slam;
| Mons.Skill.counter;
| Mons.Skill.recover;
| Mons.Skill.rock_smash;
| Mons.Skill.crunch;
| Mons.Skill.sludge_bomb;
| Mons.Skill.gyro_ball;
| Mons.Skill.iron_defense;
| Mons.Skill.super_fang;
| Mons.Skill.hypnosis;
| Mons.Skill.dream_eater;
| Mons.Skill.wing_attack;
| Mons.Skill.moonlight;
| Mons.Skill.play_rough;
| Mons.Skill.psychic;
| Mons.Skill.ancient_power;
| Mons.Skill.thunder_wave;
| Mons.Skill.charge;
| Mons.Skill.agility;


Mons.Skill.kind(kin: Mons.Kind): List(Mons.Skill)
  case kin:
  | HERO        => Mons.Skill.dummy_skills;
  | MAGE        => [];
  | BEHOLDER    => Mons.Skill.dummy_skills;
  | ZOIO        => 
    [Mons.Skill.slam, Mons.Skill.sand_tomb, 
    Mons.Skill.protect, Mons.Skill.dig];
  | CYCLOPE     => 
    [Mons.Skill.counter, Mons.Skill.recover,
    Mons.Skill.rock_smash, Mons.Skill.slam];
  | POISOLICK   => 
    [Mons.Skill.crunch, Mons.Skill.sludge_bomb,
    Mons.SKill.gyro_ball, Mons.Skill.iron_defense];
  | TROWL       => 
    [Mons.Skill.wing_attack, Mons.Skill.recover,
    Mons.Skill.agility, Mons.Skill.crunch];
  | MIMIC       => 
    [Mons.Skill.crunch, Mons.Skill.super_fang,
     Mons.Skill.hypnosis, Mons.Skill.dream_eater];
  | AZULA       => 
    [Mons.Skill.wing_attack, Mons.Skill.moonlight,
    Mons.Skill.play_rough, Mons.Skill.psychic];
  | EMERELDER   => 
    [Mons.Skill.ancient_power, Mons.Skill.thunder_wave,
    Mons.Skill.charge, Mons.Skill.iron_defense] ;

Mons.Skill.description(skill: Mons.Skill): String
  case skill:
  | hit_4 => "damage 4"; // test
  | hit_2 => "damage 2"; // test
  | heal => "heal 3"; // test
  | none => "does nothing"; // test
  | dig => "Protect for 1 turn. On the next turn, will attack and effects are applied";
  | sand_tomb => "Apply an initial dmg and +1/16 of MPH for 5 turns";
  | protect => "Avoid dmg on the next turn. Cannot be used on every turn.";
  | slam => "Damage";
  | counter => "Double the last damage that the adve received (dismiss effects)";
  | recover => "Restore 50% of mhp";
  | rock_smash => "Apply damage and 50% of change to reduce defense on the next turn";
  | crunch => "Damage and reduce adve defense";
  | sludge_bomb => "Damage and 30% of poisoning";
  | gyro_ball => "Damage and if the adve has more agi, increase dmg +25% and increase defense";
  | iron_defense => "Increase defense for 2 turns";
  | super_fang => "Damage adve with 50% of current life. Loses 50% of hp";
  | hypnosis => "Apply sleep to adve";
  | dream_eater => "Will only damage if adve is sleep. Will damage adve and heal 50% of the dmg";
  | wing_attack => "Damage";
  | moonlight => "Damage and 20% of sleep";
  | play_rough => "Damage and 20% of reduce damage";
  | psychic => "Damage and 10% of reduce damage and apply confusion";
  | ancient_power => "Damage and 10% of adve miss the attack";
  | thunder_wave => "Damage";
  | charge => "Double the damage of the next ellectric attack";
  | agility => "Increase damage and 25% of apply confusion";


Mons.Skill.get_name(skill: Mons.Skill): String
  case skill:
  | hit_4  => "hit 4";
  | hit_2  => "hit 2";
  | heal   => "heal"; 
  | none => "none";
  | dig => "Dig";
  | sand_tomb => "Sand bomb";
  | protect => "Protect";
  | slam => "Slam";
  | counter => "Counter";
  | recover => "Recover";
  | rock_smash => "Rock Smash";
  | crunch => "Crunch";
  | sludge_bomb => "Sludge bomb";
  | gyro_ball => "Gyro Ball";
  | iron_defense => "Iron Defense";
  | super_fang => "Super Fang";
  | hypnosis => "Hypnosis";
  | dream_eater => "Dream Eater";
  | wing_attack => "Wing Attack";
  | moonlight => "Moonlight";
  | play_rough => "Play Rough";
  | psychic => "Psychic";
  | ancient_power => "Ancient Power";
  | thunder_wave => "Thunder Wave";
  | charge => "Charge";
  | agility => "Agility";

Mons.Skill.update_mon_obj(
  hero_obj: Mons.Object,
  obj_updated: Mons.Object,
  pos: Pos32,
  idx: U32,
  game: Mons.Game) : Mons.Game
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then
    Mons.Game.map_set(pos, idx, obj_updated, game) // hero_obj
  else //game
    let idx_nat = U32.to_nat(hero_obj.mon)
    let new_bag = List.update_at<>(idx_nat, (a) obj_updated, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj) 
    Mons.Game.map_set(pos, idx, hero_obj, game)

Mons.Skill.damage_eff(obj: Mons.Object, pos: Pos32, idx: U32, dmg: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Object.hit(Mons.Object.get_current_mon(obj), dmg)
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.heal_eff(obj: Mons.Object, pos: Pos32, idx: U32, val: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Object.heal(Mons.Object.get_current_mon(obj), val)
  if Mons.Object.is_obj_defeated(obj_updated) then game
  else Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.invulnerable_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Effect.set_invulnerable(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.hit_next_eff(obj: Mons.Object, val: U32, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_hit(Mons.Object.get_current_mon(obj), val)
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

// pos    : position of the map in which the battle is taking place
// source : index of the object which is casting a skill
// target : index of the object which is receiving the effect 
Mons.Skill.cast(pos: Pos32, source: U32, target: U32, skill: Mons.Skill, game: Mons.Game): Mons.Game 
  open game:
  let source_obj = Mons.Map.get(pos, source, game.map)
  let source_mon = Mons.Object.get_current_mon(source_obj)
  let target_obj = Mons.Map.get(pos, target, game.map)
  let target_mon = Mons.Object.get_current_mon(target_obj)

  // Note: attr referes to the mon that the object can have
  // damage_eff and heal_eff updates the hp of the mon
  open source_mon:
  open target_mon:
  open Mons.Kind.attr(source_mon.kin) as source_mon_attr:
  open Mons.Kind.attr(target_mon.kin) as target_mon_attr:

  let light_val = 2u
  let medium_val = 4u
  let high_val = 6u

  // Cast skill
  // ----------
  case skill:
  | hit_4  =>
    let val = Mons.Type.skill_n_type(high_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);
  | hit_2 => 
    let val = Mons.Type.skill_n_type(light_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);
  | heal => Mons.Skill.heal_eff(source_obj, pos, source, 3u, game);
  | none => game;

  // TODO Invulnerable for 1 turn. On the next turn, will attack and effects are applied
  | dig => 
    let game = Mons.Skill.invulnerable_eff(source_obj, pos, source, game)
    // Will damage enemy on the next turn
    let game = Mons.Skill.hit_next_eff(target_obj, light_val, pos, target, game)
    game;

  // TODO Apply an initial dmg and +1/16 of MPH for 5 turns
  | sand_tomb => 
    let val = Mons.Type.skill_n_type(light_val, source_mon, target_mon) // insta
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // TODO Avoid dmg on the next turn. Cannot be used on every turn.
  | protect => game;

  // Damage 4
  | slam => 
    let val = Mons.Type.skill_n_type(high_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // TODO: Double the last damage that the adve received (dismiss effects)
  | counter => game;

  // TODO: Restore 50% of mhp
  | recover =>
    let val = U32.div(source_mon_attr.mhp, light_val)
    Mons.Skill.heal_eff(source_obj, pos, source, val, game);

  // Review: Apply damage and 50% of change to reduce defense on the next turn
  // TODO: add def, now is only considering mhp
  // Instant cast
  | rock_smash =>
    let red_def_val = Mons.Skill.reduce_def(target_mon_attr.mhp, medium_val, 50u, game.tik)
    let obj = Mons.Skill.damage_eff(target_obj, pos, target, red_def_val, game)
    game;

  // TODO: Damage and reduce adve defense
  | crunch => game;

  // TODO: Damage and 30% of poisoning
  | sludge_bomb => game;

  // TODO: Gyro Ball
  | gyro_ball => game;

  // TODO: Increase defense for 2 turns
  | iron_defense => game;

  // TODO: Damage adve with 50% of current life. Loses 50% of hp
  | super_fang => game;

  // TODO: Apply sleep to adve
  | hypnosis => game;

  // TODO: Will only damage if adve is sleep. Will damage adve and heal 50% of the dmg
  | dream_eater => game;

  // Damage
  | wing_attack => 
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_mon, pos, target, val, game);

  // TODO Damage and 20% of sleep
  | moonlight => game;

  // TODO Damage and 20% of reduce damage
  | play_rough => game;

  // TODO Damage and 10% of reduce damage and apply confusion
  | psychic => game;

  // TODO Damage and 10% of adve miss the attack
  | ancient_power => game;

  // Damage
  | thunder_wave =>
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // TODO Double the damage of the next ellectric attack
  | charge => game;

  // TODO Increase damage and 25% of apply confusion
  | agility => game;


Mons.Skill.reduce_def(mhp: U32, hit_val: U32, perc: U32, tik: U32): U32
  if U32.eql(U32.mod(tik, perc), 0u) then // percentage applied
    U32.add(U32.div(mhp, 16u), hit_val) // +1/16 damage
  else hit_val

// TODO remove
Mons.Skill.dummy_skills: List(Mons.Skill)
  [ Mons.Skill.hit_4, Mons.Skill.hit_2,
   Mons.Skill.heal, Mons.Skill.none ]
